geom_point() +
geom_hline(yintercept=1, linetype="dashed", color = "red")+
xlab("Time Since Tube Change") +
ylab("Ratio of Samples Kept at 4°C Prior to -80°C Storage \n against Samples Immediately Stored at -80°C") +
theme_bw() +
theme(title = element_text(size=16, face="bold"),
axis.text=element_text(size=16),
axis.title=element_text(size=16,face="bold"),
legend.title =element_text(size=16,face="bold"),
legend.text = element_text(size=16))
preservation_plot <-  preservation_plot + facet_wrap(~parameter) +
theme(strip.text.x = element_text(size = 16))
png(file.path("../report/img","preservation_plot.png"), width = 800, height = 600)
print(preservation_plot)
dev.off()
crit_pts_all_para <- data.frame()
# Derivatives of events/ul graph to determine instantaneous growth rates!!
# Trying out npregfast package to get nonparametric derivative estimations
# For Events data
crit_pts_all <- data.frame()
all_der_plots <- list()
for (letter in unique(d_ss_mean$flask)) {
# remove A because it is the time is not continuous for 24h
if (letter == "A"){
} else {
# Mask out the first and last few points from the dataset
FLASK <- d_ss_mean %>%
filter(flask == letter, hr_since_light >=2 & hr_since_light <= 23) %>%
rename(events = `Picochlorum Events/μL(V)_mean`)
# Use npregfast::frfast to get the fit data
fit <- frfast(events~ hr_since_light, data = FLASK, p=2,h0=0.16, rank1 =9, ranku= 17, kbin = 300)
# Extract Critical points data
crit_pts <-data.frame(matrix(unlist(critical(fit)), nrow=length(critical(fit)), byrow=TRUE)) %>%
mutate(der = c("Estimation","First_der","Second_der")) %>%
mutate(flask = rep(letter, 3)) %>%
rename(Critical = X1,
Lwr = X2,
Upr = X3)
# Store ALL crit pt data
crit_pts <- mutate(crit_pts, light_regime = rep(FLASK$light_regime[1],nrow(crit_pts)))
crit_pts_all <- rbind(crit_pts_all, crit_pts)
# Create plots
est_plot <- autoplot(fit) +
geom_vline(xintercept = crit_pts[2,1], col = "red") +
scale_x_continuous(breaks = breaks_width(2, 0)) +
ggtitle(paste("Flask",letter, sep = " ")) +
labs(x = 'Hours Since Start', y = 'Cells/μL')
plot_limits <-get_plot_limits(est_plot)
est_plot <- est_plot + annotate(geom = "rect",
xmin=filter(flaskdata, flask ==letter)$dark1_since_light1,
xmax=filter(flaskdata, flask ==letter)$light2_since_light1,
ymin=plot_limits[[3]],
ymax=plot_limits[[4]], alpha= 0.3, fill = "black")
der1_plot <- autoplot(fit, der = 1) +
geom_vline(xintercept = crit_pts[2,1], col = "red") +
scale_y_continuous(breaks = breaks_pretty(6),labels = hr2day) +
scale_x_continuous(breaks = breaks_width(2, 0)) +
labs(x = 'Hours Since Start', y = bquote(bold("day"^-1)))
plot_limits <-get_plot_limits(der1_plot)
der1_plot <- der1_plot + annotate(geom = "rect",
xmin=filter(flaskdata, flask ==letter)$dark1_since_light1,
xmax=filter(flaskdata, flask ==letter)$light2_since_light1,
ymin=plot_limits[[3]],
ymax=plot_limits[[4]], alpha= 0.3, fill = "black")
# Change colour of lines for each light_regime
if (FLASK$light_regime[1] == "1608"){
use_col <- gg_color_hue(3)[3]
}else if (FLASK$light_regime[1] == "1212") {
use_col <- gg_color_hue(3)[2]
} else {
use_col <- gg_color_hue(3)[1]
}
# Store the derivative plot and add flask name
# Also add text indicating light regime
grob <- grobTree(textGrob(paste("Light Regime: ", FLASK$light_regime[1]), x=0,  y=0.95, hjust=0,
gp=gpar(col=use_col, fontsize=18)))
xmin<- 2.5
xmax<-21.5
if(filter(flaskdata, flask ==letter)$dark1_since_light1[1] <= xmin){
darkmin <- xmin
} else {darkmin<- filter(flaskdata, flask ==letter)$dark1_since_light1}
if(filter(flaskdata, flask ==letter)$light2_since_light1[1]>=xmax){
darkmax <- xmax
} else {darkmax <- filter(flaskdata, flask ==letter)$light2_since_light1}
all_der_plots[[letter]] <- der1_plot +
ggtitle(paste("Flask",letter, sep = " ")) +
annotation_custom(grob) +
scale_x_continuous(breaks = breaks_width(2, 0), limits = c(xmin,xmax)) +
annotate(geom = "rect",
xmin=darkmin,
xmax=darkmax,
ymin=plot_limits[[3]],
ymax=plot_limits[[4]], alpha= 0.3, fill = "black") +
geom_vline(xintercept = crit_pts[2,1], col = use_col, lwd = 2) +
theme(title = element_text(size=18, face="bold"),
axis.text=element_text(size=18),
axis.title=element_text(size=18,face="bold"),
legend.title =element_text(size=18,face="bold"),
legend.text = element_text(size=18))
# create list for grobs in gridExtra
der1_plot <- der1_plot +
theme(title = element_text(size=18, face="bold"),
axis.text=element_text(size=18),
axis.title=element_text(size=18,face="bold"),
legend.title =element_text(size=18,face="bold"),
legend.text = element_text(size=18))
est_plot <- est_plot + theme(title = element_text(size=18, face="bold"),
axis.text=element_text(size=18),
axis.title=element_text(size=18,face="bold"),
legend.title =element_text(size=18,face="bold"),
legend.text = element_text(size=18))
p <- list(est_plot,der1_plot)
# Store plots in img folder
dev.new()
png(file.path("../report/img",paste("model_EVENTS_der", letter, ".png", sep="_")), width = 800, height = 600)
gridExtra::grid.arrange(grobs = p, ncol = 1, nrow = length(p))
dev.off()
}
}
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
cache=TRUE,
prompt=FALSE,
tidy=TRUE,
comment=NA,
message=FALSE,
warning=FALSE,
tidy = FALSE,
fig.height=8,
fig.width=8,
results = 'asis')
opts_knit$set(width=75)
library("ggplot2")
library("dplyr")
library("plotrix" ) # needed for standard error
library("readxl") # Read excel file
library("readr")
library("lubridate")
library("tidyr")
library("pspline")
library("npregfast")
library("ggpmisc")
library(mgcv)
library(scales)
library(grid)
library(stargazer)
# This is to clear the device list (dev.list())
graphics.off()
# Create function to get plot limits of a ggplot (for creation of grey box)
get_plot_limits <- function(plot) {
gb = ggplot_build(plot)
xmin = gb$layout$panel_params[[1]]$x.range[1]
xmax = gb$layout$panel_params[[1]]$x.range[2]
ymin = gb$layout$panel_params[[1]]$y.range[1]
ymax = gb$layout$panel_params[[1]]$y.range[2]
list(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax)
}
# Create function to emulate ggplot colour scheme:
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
# Create a function for the transformation of the y-axis for the derivative. This is to label the growth rate in d^-1.
hr2day <- function (x) { scales::label_number(accuracy = 0.001,
scale = 1/24,
big.mark = ",")(x)
}
# Read the metadata
flaskdata <- read_csv("../data/metadata/flaskdata.csv")
# Add time elapsed since culture start
flaskdata <- flaskdata %>%
dplyr::mutate(julian_culture_st= make_datetime(flaskdata$`culture year`,flaskdata$`culture month`,flaskdata$`culture day`,flaskdata$`culture hour`,flaskdata$`culture min`)) %>%
dplyr::mutate(julian_sample_st= make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`,flaskdata$`sample hour`,flaskdata$`sample min`))%>%
dplyr::mutate(days_elapsed = julian_sample_st-julian_culture_st) %>%
dplyr::mutate(FA = paste(flask,attempt, sep = "")) %>%
dplyr::mutate(light_on = format(make_datetime(hour = flaskdata$`light hour`, min = flaskdata$`light min`), format = "%H:%M:%S")) %>%
dplyr::mutate(dark_on = format(make_datetime(hour = flaskdata$`dark hour`, min = flaskdata$`dark min`), format = "%H:%M:%S")) %>%
dplyr::mutate(light_on_datetime_1 = make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`,flaskdata$`light hour`, flaskdata$`light min`)) %>%
dplyr::mutate(dark_on_datetime_1 = make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`,flaskdata$`dark hour`, flaskdata$`dark min`)) %>%
dplyr::mutate(light_on_datetime_2 = make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`+1,flaskdata$`light hour`, flaskdata$`light min`)) %>%
dplyr::mutate(dark_on_datetime_2 = make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`+1,flaskdata$`dark hour`, flaskdata$`dark min`)) %>%
dplyr::mutate(datetime_1_tube_change= make_datetime(flaskdata$`1 tube change year`,flaskdata$`1 tube change month`,flaskdata$`1 tube change day`,flaskdata$`1 tube change hour`,flaskdata$`1 tube change min`))  %>%
dplyr::mutate(datetime_2_tube_change= make_datetime(flaskdata$`2 tube change year`,flaskdata$`2 tube change month`,flaskdata$`2 tube change day`,flaskdata$`2 tube change hour`,flaskdata$`2 tube change min`))  %>%
dplyr::mutate(datetime_3_tube_change= make_datetime(flaskdata$`3 tube change year`,flaskdata$`3 tube change month`,flaskdata$`3 tube change day`,flaskdata$`3 tube change hour`,flaskdata$`3 tube change min`))  %>%
dplyr::mutate(datetime_4_tube_change= make_datetime(flaskdata$`4 tube change year`,flaskdata$`4 tube change month`,flaskdata$`4 tube change day`,flaskdata$`4 tube change hour`,flaskdata$`4 tube change min`))
flaskdata <- flaskdata %>%
mutate(dark1_since_light1 = time_length(flaskdata$dark_on_datetime_1 - flaskdata$light_on_datetime_1, unit="hour")) %>%
mutate(light2_since_light1 = time_length(flaskdata$light_on_datetime_2 - flaskdata$light_on_datetime_1, unit="hour"))
## Read the data
# Find all csv files
myfiles = list.files(path="../data", pattern="*.csv", full.names=TRUE)
# Read all csv files
data_all <- lapply(myfiles, read_csv, skip =2)
data <- do.call(rbind, data_all)
# Split the tube names
data <- data %>%
dplyr::mutate(flask =  substr(`Tube Name:`, 1,1),
attempt = substr(`Tube Name:`, 2,2),
hour_index = substr(`Tube Name:`, 3,4),
AorM = substr(`Tube Name:`, 5,5),
repli = substr(`Tube Name:`, 6,6)
) %>%
dplyr::mutate(FA = paste(flask,attempt, sep = ""),
FAhi = paste(flask, attempt,hour_index, sep = ""))
## Compare both dataframes to get julian start time and light regime
julian_time <- data.frame()
light_regime <- data.frame()
for (row in 1:nrow(data)){
index <- match(data[row,"FA"],flaskdata$FA)
julian_time <- rbind(julian_time,as.numeric(flaskdata[index,"days_elapsed"])+as.numeric(data[row,"hour_index"])/24)
light_regime <- rbind(light_regime, flaskdata[index,"light regime"])
}
names(julian_time)[1] <- "julian_time"
data<- cbind(data, julian_time)
names(light_regime)[1] <- "light_regime"
data<- cbind(data, light_regime)
# Add time sampled
data <- data %>%
dplyr::mutate(julian_time_diff = as.difftime(data$julian_time, format = "%d", units = "days"))
sample_datetime <- data.frame()
for (row in 1:nrow(data)){
index <- match(data[row,"FA"],flaskdata$FA)
sample_datetime <- rbind(sample_datetime, flaskdata[index,"julian_culture_st"]+data.frame(data[row,"julian_time_diff"]))
}
names(sample_datetime)[1] <- "sample_datetime"
data<- cbind(data, sample_datetime)
# Extract just time from sample
data <- data %>%
dplyr::mutate(sample_time = format(sample_datetime, format = "%H:%M:%S"))
# data$sample_time <- strptime(data$sample_time,format="%H:%M")
# Loop through data to add hour since light on and "Light" or "Dark" as a another variable in the last column
lightORdark <- data.frame()
LorD<- ""
hr_since_light <- data.frame()
hr_since_light_var <- ""
# Check if it is light or dark
for (row in 1:nrow(data)){
index <- match(data[row,"FA"],flaskdata$FA)
hr_since_light_var <- time_length(data[row,"sample_datetime"]- flaskdata[[index,"light_on_datetime_1"]], unit="hour")
hr_since_light <- rbind(hr_since_light, data.frame(hr_since_light_var))
# A, B, E, F have dark cycles ending after midnight. The rest of the samples cycles should end before midnight.
if(data[row,"flask"] == "A" | data[row,"flask"] == "B" |data[row,"flask"] == "E"|data[row,"flask"] == "F"){
ifelse(data[row,"sample_time"] >= flaskdata[index,"dark_on"] & data[row,"sample_time"] <= flaskdata[index,"light_on"], LorD <- "dark", LorD <- "light")
}
else {
ifelse(data[row,"sample_time"] >= flaskdata[index,"light_on"] & data[row,"sample_time"] <= flaskdata[index,"dark_on"], LorD <- "light", LorD <- "dark")
}
lightORdark <- rbind(lightORdark, data.frame(LorD))
}
names(hr_since_light)[1] <- "hr_since_light"
names(lightORdark)[1] <- "lightORdark"
data<- cbind(data, hr_since_light, lightORdark)
# Loop through data and compare sampling times with the tube change data to determine how long it has been sitting in the sampler for
time_since_tube_change <- data.frame()
time_tube_change <- ""
# data<- filter(data,flask == "E")
for (row in 1:nrow(data)) {
index <- match(data[row,"FA"],flaskdata$FA)
if(data[row,"AorM"] == "A"){
if (is.na(flaskdata[index,"datetime_1_tube_change"]) == "TRUE"){time_tube_change <- 0}
else if (as.numeric(data[row,"sample_datetime"]) < as.numeric(flaskdata[index,"datetime_1_tube_change"])){
time_tube_change <- as.numeric(flaskdata[index,"datetime_1_tube_change"]) - as.numeric(data[row,"sample_datetime"])
}
else if (is.na(flaskdata[index,"datetime_2_tube_change"]) == "TRUE"){time_tube_change <- 0}
else if (as.numeric(data[row,"sample_datetime"]) >= as.numeric(flaskdata[index,"datetime_1_tube_change"]) & as.numeric(data[row,"sample_datetime"]) < as.numeric(flaskdata[index,"datetime_2_tube_change"])){
time_tube_change <- as.numeric(flaskdata[index,"datetime_2_tube_change"]) - as.numeric(data[row,"sample_datetime"])
}
else if (is.na(flaskdata[index,"datetime_3_tube_change"]) == "TRUE"){time_tube_change <- 0}
else if (as.numeric(data[row,"sample_datetime"]) >= as.numeric(flaskdata[index,"datetime_2_tube_change"]) & as.numeric(data[row,"sample_datetime"]) < as.numeric(flaskdata[index,"datetime_3_tube_change"])){
time_tube_change <- as.numeric(flaskdata[index,"datetime_3_tube_change"]) - as.numeric(data[row,"sample_datetime"])
}
else if (is.na(flaskdata[index,"datetime_4_tube_change"]) == "TRUE"){time_tube_change <- 0}
else if (as.numeric(data[row,"sample_datetime"]) >= as.numeric(flaskdata[index,"datetime_2_tube_change"]) & as.numeric(data[row,"sample_datetime"]) < as.numeric(flaskdata[index,"datetime_3_tube_change"])){
time_tube_change <- as.numeric(flaskdata[index,"datetime_4_tube_change"]) - as.numeric(data[row,"sample_datetime"])
}
else {
time_tube_change <- 0
}
}
else {time_tube_change <- 0}
# divide by 3600 because POSIXct as.numeric is in seconds. So final is hours since tube change.
time_since_tube_change <- rbind(time_since_tube_change, time_tube_change/3600)
}
names(time_since_tube_change)[1] <- "time_since_tube_change"
data<- cbind(data, time_since_tube_change)
## An Explanation of variables:
# Geom. Mean—The geometric mean. Can be a more applicable metric for a log-normal distribution. It is always less than or equal to the arithmetic mean.
# Robust Standard Deviation—68.26% of the events around the Median are used for this calculation, and an upper and lower range set.  The robust standard deviation is equal to (upper range + lower range) /2.  If the upper range is off scale, the robust standard deviation is equal to the lower range, and vice versa when the lower range is off scale and the robust standard deviation is the upper range.  The robust standard deviation is not as skewed by outlying values as the Standard Deviation.
# Robust CV—Equals 100 * 1/2( Intensity[at 84.13 percentile] – Intensity [at 15.87 percentile] ) / Median. The robust CV is not as skewed by outlying values as the CV.
# Extract the more useful data
d_ss <- data %>%
select(`flask`,attempt, hour_index, hr_since_light, FAhi, AorM, repli,light_regime,julian_time,sample_datetime, sample_time,lightORdark,time_since_tube_change,`Picochlorum Events/μL(V)`, `Picochlorum Median FSC-A`, `Picochlorum Median SSC-A`, `Picochlorum Median PC5.5-A`)
# Gets the mean of replicates
d_ss_mean <- d_ss %>%
group_by(flask, attempt,hour_index, hr_since_light, FAhi, AorM,light_regime, julian_time,sample_datetime, sample_time, lightORdark, time_since_tube_change) %>%
summarise_at(.vars = names(.)[14:17],
.funs = c(mean="mean"))
# Add in temp and humidity data from Govee recording device
# Read the Temperature Data
myfiles = list.files(path="../data/metadata/GEEK temp sensor1615178083103_export", pattern="*.csv", full.names=TRUE)
data_all <- lapply(myfiles, read_csv)
tempdata <- do.call(rbind, data_all)
colnames(tempdata) <- c("datetime", "Temperature", "Humidity")
temp <- ggplot(tempdata, aes(x = datetime, y = Temperature)) +
geom_line() +
geom_smooth() +
xlab("Date") +
ylab("Temperature (°C)") +
scale_x_datetime(breaks = date_breaks("weeks"), labels = date_format("%b %d")) +
theme(title = element_text(size=16, face="bold"),
axis.text=element_text(size=20),
axis.title=element_text(size=20,face="bold"),
legend.title =element_text(size=18,face="bold"),
legend.text = element_text(size=18))
png(file.path("../report/img","Temp.png"), width = 1200, height = 600)
print(temp)
dev.off()
# TEMPORARY GRAPHIC - This includes code for:
# Log transformation of y axis
# Addition of grey box for dark portion of light regime
# to add:
# Make axis ticks better and overall aesthetic...
FLASK<- filter(d_ss,flask == "E")
events <- ggplot(FLASK, aes(x = sample_datetime, y = `Picochlorum Events/μL(V)`))+
scale_y_continuous(trans = "log10", sec.axis = sec_axis(~./4, name = "Temperature"))
plot_limits<-get_plot_limits(events)
events <- events + annotate(geom = "rect",
xmin=as_datetime(filter(flaskdata, flask =="E")$dark_on_datetime_1),
xmax=as_datetime(filter(flaskdata, flask =="E")$light_on_datetime_2),
ymin=10^plot_limits[[3]],
ymax=10^plot_limits[[4]], alpha= 0.5, fill = "black") +
geom_point(aes(color = AorM)) +
xlab("Sample Date Time") +
ylab("Log(Events/μL)") +
ggtitle("All Flasks Picochlorum Events/μL")
labs(col="Light \nCondition") +
theme_bw()+
theme(axis.text=element_text(size=12),
axis.title=element_text(size=12,face="bold"),
legend.title =element_text(size=12,face="bold"),
legend.text = element_text(size=12),
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
#png(file.path("../report/img","Events_Facet_Wrap.png"), width = 800, height = 600)
print(events)
#dev.off()
# Comparing A and M samples
# Keep only rows of FAhi where both A and M exist
d_ss_mean_AM <- subset(d_ss_mean, FAhi %in% d_ss_mean[duplicated(d_ss_mean$FAhi),"FAhi"]$FAhi)
# Compare differences in
d_ss_mean_AM_A <- filter(d_ss_mean_AM,AorM == "A")
d_ss_mean_AM_M <- filter(d_ss_mean_AM,AorM == "M")
d_ss_mean_AM_A_ratio <-data.frame(c(d_ss_mean_AM_A[12],d_ss_mean_AM_A[-c(1:12)]/d_ss_mean_AM_M[-c(1:12)]))%>%
rename("Cells/μL" = Picochlorum.Events.μL.V._mean,
"FSC" = Picochlorum.Median.FSC.A_mean,
"SSC" = Picochlorum.Median.SSC.A_mean,
"PC5.5" = Picochlorum.Median.PC5.5.A_mean)
d_ss_mean_AM_A_ratio <- d_ss_mean_AM_A_ratio %>% gather(parameter, ratio, -time_since_tube_change)
preservation_plot <- ggplot(d_ss_mean_AM_A_ratio, aes(x = time_since_tube_change, y = ratio))+
geom_point() +
geom_hline(yintercept=1, linetype="dashed", color = "red")+
xlab("Time Since Tube Change") +
ylab("Ratio of Samples Kept at 4°C Prior to -80°C Storage \n against Samples Immediately Stored at -80°C") +
theme_bw() +
theme(title = element_text(size=16, face="bold"),
axis.text=element_text(size=16),
axis.title=element_text(size=16,face="bold"),
legend.title =element_text(size=16,face="bold"),
legend.text = element_text(size=16))
preservation_plot <-  preservation_plot + facet_wrap(~parameter) +
theme(strip.text.x = element_text(size = 16))
png(file.path("../report/img","preservation_plot.png"), width = 800, height = 600)
print(preservation_plot)
dev.off()
crit_pts_all_para <- data.frame()
# Derivatives of events/ul graph to determine instantaneous growth rates!!
# Trying out npregfast package to get nonparametric derivative estimations
# For Events data
crit_pts_all <- data.frame()
all_der_plots <- list()
for (letter in unique(d_ss_mean$flask)) {
# remove A because it is the time is not continuous for 24h
if (letter == "A"){
} else {
# Mask out the first and last few points from the dataset
FLASK <- d_ss_mean %>%
filter(flask == letter, hr_since_light >=2 & hr_since_light <= 23) %>%
rename(events = `Picochlorum Events/μL(V)_mean`)
# Use npregfast::frfast to get the fit data
fit <- frfast(events~ hr_since_light, data = FLASK, p=2,h0=0.16, rank1 =9, ranku= 17, kbin = 300)
# Extract Critical points data
crit_pts <-data.frame(matrix(unlist(critical(fit)), nrow=length(critical(fit)), byrow=TRUE)) %>%
mutate(der = c("Estimation","First_der","Second_der")) %>%
mutate(flask = rep(letter, 3)) %>%
rename(Critical = X1,
Lwr = X2,
Upr = X3)
# Store ALL crit pt data
crit_pts <- mutate(crit_pts, light_regime = rep(FLASK$light_regime[1],nrow(crit_pts)))
crit_pts_all <- rbind(crit_pts_all, crit_pts)
# Create plots
est_plot <- autoplot(fit) +
geom_vline(xintercept = crit_pts[2,1], col = "red") +
scale_x_continuous(breaks = breaks_width(2, 0)) +
ggtitle(paste("Flask",letter, sep = " ")) +
labs(x = 'Hours Since Start', y = 'Cells/μL')
plot_limits <-get_plot_limits(est_plot)
est_plot <- est_plot + annotate(geom = "rect",
xmin=filter(flaskdata, flask ==letter)$dark1_since_light1,
xmax=filter(flaskdata, flask ==letter)$light2_since_light1,
ymin=plot_limits[[3]],
ymax=plot_limits[[4]], alpha= 0.3, fill = "black")
der1_plot <- autoplot(fit, der = 1) +
geom_vline(xintercept = crit_pts[2,1], col = "red") +
scale_y_continuous(breaks = breaks_pretty(6),labels = hr2day) +
scale_x_continuous(breaks = breaks_width(2, 0)) +
labs(x = 'Hours Since Start', y = bquote(bold("day"^-1)))
plot_limits <-get_plot_limits(der1_plot)
der1_plot <- der1_plot + annotate(geom = "rect",
xmin=filter(flaskdata, flask ==letter)$dark1_since_light1,
xmax=filter(flaskdata, flask ==letter)$light2_since_light1,
ymin=plot_limits[[3]],
ymax=plot_limits[[4]], alpha= 0.3, fill = "black")
# Change colour of lines for each light_regime
if (FLASK$light_regime[1] == "1608"){
use_col <- gg_color_hue(3)[3]
}else if (FLASK$light_regime[1] == "1212") {
use_col <- gg_color_hue(3)[2]
} else {
use_col <- gg_color_hue(3)[1]
}
# Store the derivative plot and add flask name
# Also add text indicating light regime
grob <- grobTree(textGrob(paste("Light Regime: ", FLASK$light_regime[1]), x=0,  y=0.95, hjust=0,
gp=gpar(col=use_col, fontsize=18)))
xmin<- 2.5
xmax<-21.5
if(filter(flaskdata, flask ==letter)$dark1_since_light1[1] <= xmin){
darkmin <- xmin
} else {darkmin<- filter(flaskdata, flask ==letter)$dark1_since_light1}
if(filter(flaskdata, flask ==letter)$light2_since_light1[1]>=xmax){
darkmax <- xmax
} else {darkmax <- filter(flaskdata, flask ==letter)$light2_since_light1}
all_der_plots[[letter]] <- der1_plot +
ggtitle(paste("Flask",letter, sep = " ")) +
annotation_custom(grob) +
scale_x_continuous(breaks = breaks_width(2, 0), limits = c(xmin,xmax)) +
annotate(geom = "rect",
xmin=darkmin,
xmax=darkmax,
ymin=plot_limits[[3]],
ymax=plot_limits[[4]], alpha= 0.3, fill = "black") +
geom_vline(xintercept = crit_pts[2,1], col = use_col, lwd = 2) +
theme(title = element_text(size=18, face="bold"),
axis.text=element_text(size=18),
axis.title=element_text(size=18,face="bold"),
legend.title =element_text(size=18,face="bold"),
legend.text = element_text(size=18))
# create list for grobs in gridExtra
der1_plot <- der1_plot +
theme(title = element_text(size=18, face="bold"),
axis.text=element_text(size=18),
axis.title=element_text(size=18,face="bold"),
legend.title =element_text(size=18,face="bold"),
legend.text = element_text(size=18))
est_plot <- est_plot + theme(title = element_text(size=18, face="bold"),
axis.text=element_text(size=18),
axis.title=element_text(size=18,face="bold"),
legend.title =element_text(size=18,face="bold"),
legend.text = element_text(size=18))
p <- list(est_plot,der1_plot)
# Store plots in img folder
dev.new()
png(file.path("../report/img",paste("model_EVENTS_der", letter, ".png", sep="_")), width = 800, height = 600)
gridExtra::grid.arrange(grobs = p, ncol = 1, nrow = length(p))
dev.off()
}
}
# Create a plot of all derivatives stacked on top of each other (except A, H, and I)
# remove unnecessary plots from list
all_der_plots <- within(all_der_plots, rm(H, I))
# Reorder so that light regimes are in order
all_der_plots <- all_der_plots[c("B", "E", "F", "G", "L", "J", "K")]
dev.new()
png(file.path("../report/img",paste("model_EVENTS_der", "ALL", ".png", sep="_")), width = 1400, height = 1600)
gridExtra::grid.arrange(grobs = all_der_plots , ncol = 1, nrow = length(all_der_plots))
dev.off()
# Make a scatter plot for the points
events_change <- crit_pts_all%>%
filter(der == "First_der") %>%
select(Critical, flask) %>%
mutate(light_regime = c("1608", "1608", "1608", "1212", "1212", "0816", "0816", "0816", "1212")) %>%
filter(flask %in% c("B", "E", "F", "G", "J", "K", "L"))
dev.new()
png(file.path("../report/img",paste("Max_Events", "Change", ".png", sep="_")), width = 1200, height = 300)
ggplot(events_change, aes(light_regime, Critical))+
geom_point(aes(color = light_regime, size = 2)) +
coord_flip() +
geom_text(aes(label= flask),hjust=1.5, vjust=-1) +
scale_y_continuous(limits = c(range(events_change$Critical)[1]-1,range(events_change$Critical)[2]+1 )) +
theme_bw() +
ggtitle("Events change") +
theme(axis.text=element_text(size=16),
axis.title=element_text(size=16,face="bold"),
legend.title =element_text(size=16,face="bold"),
legend.text = element_text(size=16))
dev.off()
crit_pts_all <- mutate(crit_pts_all, parameter = rep("events", nrow(crit_pts_all)))
crit_pts_all_para <- rbind(crit_pts_all_para, crit_pts_all)
graphics.off()
