---
title: "Picochlorum Growth Rate Analysis"
date: "`r Sys.Date()`"
author: "David Mah"
output:
  html_document: default
  rmdformats::readthedown:
    highlight: kate
  rmarkdown::html_vignette: 
    css: 
    - !expr system.file("rmarkdown/templates/html_vignette/resources/vignette.css", package = "rmarkdown")
    - !expr system.file("includes/stylesheets/summarytools.css", package = "summarytools")
  prettydoc::html_pretty:
    theme: architect
    highlight: github  
---

This is for knit formatting. Don't really need it.
```{r knitr_init, echo=FALSE, cache=FALSE, warning=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               tidy = FALSE,
               fig.height=8, 
               fig.width=8,
               results = 'asis')
opts_knit$set(width=75)
```

This adds all the libraries you need to run
```{r, message=FALSE, warning=FALSE}
library("ggplot2")
library("dplyr")
library("plotrix" ) # needed for standard error
library("readxl") # Read excel file
library("readr") 
library("lubridate") 
library("tidyr") 
library("pspline")
library("npregfast")
library("ggpmisc")
library(mgcv)
library(scales)
library(grid)

# This is to clear the device list (dev.list()) 
graphics.off()
 
```

This adds all the custom functions used throughout the script
```{r}
# Create function to get plot limits of a ggplot (for creation of grey box)
get_plot_limits <- function(plot) {
    gb = ggplot_build(plot)
    xmin = gb$layout$panel_params[[1]]$x.range[1]
    xmax = gb$layout$panel_params[[1]]$x.range[2]
    ymin = gb$layout$panel_params[[1]]$y.range[1]
    ymax = gb$layout$panel_params[[1]]$y.range[2]
    list(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax)
    }

# Create function to emulate ggplot colour scheme: 
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
  }

# Create a function for the transformation of the y-axis for the derivative. This is to label the growth rate in d^-1. 
hr2day <- function (x) { scales::label_number(accuracy = 0.001,
                                       scale = 1/24,
                                       big.mark = ",")(x) 
  }


```

This chunk summons ALL the data and pre-processes it. 
```{r, echo = FALSE, message = FALSE}

# Read the metadata
flaskdata <- read_csv("../data/metadata/flaskdata.csv")

# Add time elapsed since culture start
flaskdata <- flaskdata %>% 
  dplyr::mutate(julian_culture_st= make_datetime(flaskdata$`culture year`,flaskdata$`culture month`,flaskdata$`culture day`,flaskdata$`culture hour`,flaskdata$`culture min`)) %>% 
  dplyr::mutate(julian_sample_st= make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`,flaskdata$`sample hour`,flaskdata$`sample min`))%>% 
  dplyr::mutate(days_elapsed = julian_sample_st-julian_culture_st) %>% 
  dplyr::mutate(FA = paste(flask,attempt, sep = "")) %>%
  dplyr::mutate(light_on = format(make_datetime(hour = flaskdata$`light hour`, min = flaskdata$`light min`), format = "%H:%M:%S")) %>%
  dplyr::mutate(dark_on = format(make_datetime(hour = flaskdata$`dark hour`, min = flaskdata$`dark min`), format = "%H:%M:%S")) %>%
  dplyr::mutate(light_on_datetime_1 = make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`,flaskdata$`light hour`, flaskdata$`light min`)) %>%
  dplyr::mutate(dark_on_datetime_1 = make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`,flaskdata$`dark hour`, flaskdata$`dark min`)) %>%
  dplyr::mutate(light_on_datetime_2 = make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`+1,flaskdata$`light hour`, flaskdata$`light min`)) %>%
  dplyr::mutate(dark_on_datetime_2 = make_datetime(flaskdata$`sample year`,flaskdata$`sample month`,flaskdata$`sample day`+1,flaskdata$`dark hour`, flaskdata$`dark min`)) %>%
  dplyr::mutate(datetime_1_tube_change= make_datetime(flaskdata$`1 tube change year`,flaskdata$`1 tube change month`,flaskdata$`1 tube change day`,flaskdata$`1 tube change hour`,flaskdata$`1 tube change min`))  %>% 
  dplyr::mutate(datetime_2_tube_change= make_datetime(flaskdata$`2 tube change year`,flaskdata$`2 tube change month`,flaskdata$`2 tube change day`,flaskdata$`2 tube change hour`,flaskdata$`2 tube change min`))  %>% 
  dplyr::mutate(datetime_3_tube_change= make_datetime(flaskdata$`3 tube change year`,flaskdata$`3 tube change month`,flaskdata$`3 tube change day`,flaskdata$`3 tube change hour`,flaskdata$`3 tube change min`))  %>%
  dplyr::mutate(datetime_4_tube_change= make_datetime(flaskdata$`4 tube change year`,flaskdata$`4 tube change month`,flaskdata$`4 tube change day`,flaskdata$`4 tube change hour`,flaskdata$`4 tube change min`))

flaskdata <- flaskdata %>%
  mutate(dark1_since_light1 = time_length(flaskdata$dark_on_datetime_1 - flaskdata$light_on_datetime_1, unit="hour")) %>%
  mutate(light2_since_light1 = time_length(flaskdata$light_on_datetime_2 - flaskdata$light_on_datetime_1, unit="hour"))

## Read the data

# Find all csv files 
myfiles = list.files(path="../data", pattern="*.csv", full.names=TRUE)

# Read all csv files
data_all <- lapply(myfiles, read_csv, skip =2)
data <- do.call(rbind, data_all)

# Split the tube names
data <- data %>%
  dplyr::mutate(flask =  substr(`Tube Name:`, 1,1), 
                attempt = substr(`Tube Name:`, 2,2),
                hour_index = substr(`Tube Name:`, 3,4),
                AorM = substr(`Tube Name:`, 5,5),
                repli = substr(`Tube Name:`, 6,6)
                ) %>%
  dplyr::mutate(FA = paste(flask,attempt, sep = ""),
                FAhi = paste(flask, attempt,hour_index, sep = ""))

## Compare both dataframes to get julian start time and light regime
julian_time <- data.frame()
light_regime <- data.frame()
for (row in 1:nrow(data)){
index <- match(data[row,"FA"],flaskdata$FA)
julian_time <- rbind(julian_time,as.numeric(flaskdata[index,"days_elapsed"])+as.numeric(data[row,"hour_index"])/24)
light_regime <- rbind(light_regime, flaskdata[index,"light regime"])
}
names(julian_time)[1] <- "julian_time"
data<- cbind(data, julian_time)
names(light_regime)[1] <- "light_regime"
data<- cbind(data, light_regime)

# Add time sampled 
data <- data %>%
  dplyr::mutate(julian_time_diff = as.difftime(data$julian_time, format = "%d", units = "days"))
sample_datetime <- data.frame()
for (row in 1:nrow(data)){
index <- match(data[row,"FA"],flaskdata$FA)
sample_datetime <- rbind(sample_datetime, flaskdata[index,"julian_culture_st"]+data.frame(data[row,"julian_time_diff"]))
}
names(sample_datetime)[1] <- "sample_datetime"
data<- cbind(data, sample_datetime)

# Extract just time from sample
data <- data %>%
  dplyr::mutate(sample_time = format(sample_datetime, format = "%H:%M:%S"))
# data$sample_time <- strptime(data$sample_time,format="%H:%M")

# Loop through data to add hour since light on and "Light" or "Dark" as a another variable in the last column 
lightORdark <- data.frame()
LorD<- ""
hr_since_light <- data.frame()
hr_since_light_var <- ""
# Check if it is light or dark
for (row in 1:nrow(data)){
index <- match(data[row,"FA"],flaskdata$FA)
hr_since_light_var <- time_length(data[row,"sample_datetime"]- flaskdata[[index,"light_on_datetime_1"]], unit="hour")
hr_since_light <- rbind(hr_since_light, data.frame(hr_since_light_var))
# A, B, E, F have dark cycles ending after midnight. The rest of the samples cycles should end before midnight. 
if(data[row,"flask"] == "A" | data[row,"flask"] == "B" |data[row,"flask"] == "E"|data[row,"flask"] == "F"){
  ifelse(data[row,"sample_time"] >= flaskdata[index,"dark_on"] & data[row,"sample_time"] <= flaskdata[index,"light_on"], LorD <- "dark", LorD <- "light")
  }
else {
  ifelse(data[row,"sample_time"] >= flaskdata[index,"light_on"] & data[row,"sample_time"] <= flaskdata[index,"dark_on"], LorD <- "light", LorD <- "dark")
  }
lightORdark <- rbind(lightORdark, data.frame(LorD))
}
names(hr_since_light)[1] <- "hr_since_light"
names(lightORdark)[1] <- "lightORdark"
data<- cbind(data, hr_since_light, lightORdark)


# Loop through data and compare sampling times with the tube change data to determine how long it has been sitting in the sampler for

time_since_tube_change <- data.frame()
time_tube_change <- ""

# data<- filter(data,flask == "E")

for (row in 1:nrow(data)) {
  index <- match(data[row,"FA"],flaskdata$FA)
  if(data[row,"AorM"] == "A"){
    if (is.na(flaskdata[index,"datetime_1_tube_change"]) == "TRUE"){time_tube_change <- 0}
    else if (as.numeric(data[row,"sample_datetime"]) < as.numeric(flaskdata[index,"datetime_1_tube_change"])){
      time_tube_change <- as.numeric(flaskdata[index,"datetime_1_tube_change"]) - as.numeric(data[row,"sample_datetime"])
    }
    else if (is.na(flaskdata[index,"datetime_2_tube_change"]) == "TRUE"){time_tube_change <- 0}
    else if (as.numeric(data[row,"sample_datetime"]) >= as.numeric(flaskdata[index,"datetime_1_tube_change"]) & as.numeric(data[row,"sample_datetime"]) < as.numeric(flaskdata[index,"datetime_2_tube_change"])){
      time_tube_change <- as.numeric(flaskdata[index,"datetime_2_tube_change"]) - as.numeric(data[row,"sample_datetime"])
    }
    else if (is.na(flaskdata[index,"datetime_3_tube_change"]) == "TRUE"){time_tube_change <- 0}
    else if (as.numeric(data[row,"sample_datetime"]) >= as.numeric(flaskdata[index,"datetime_2_tube_change"]) & as.numeric(data[row,"sample_datetime"]) < as.numeric(flaskdata[index,"datetime_3_tube_change"])){
      time_tube_change <- as.numeric(flaskdata[index,"datetime_3_tube_change"]) - as.numeric(data[row,"sample_datetime"])
    }
    else if (is.na(flaskdata[index,"datetime_4_tube_change"]) == "TRUE"){time_tube_change <- 0}
    else if (as.numeric(data[row,"sample_datetime"]) >= as.numeric(flaskdata[index,"datetime_2_tube_change"]) & as.numeric(data[row,"sample_datetime"]) < as.numeric(flaskdata[index,"datetime_3_tube_change"])){
      time_tube_change <- as.numeric(flaskdata[index,"datetime_4_tube_change"]) - as.numeric(data[row,"sample_datetime"])
    }
    else {
      time_tube_change <- 0
    }
  }
else {time_tube_change <- 0}
  
# divide by 3600 because POSIXct as.numeric is in seconds. So final is hours since tube change. 
time_since_tube_change <- rbind(time_since_tube_change, time_tube_change/3600)
}
names(time_since_tube_change)[1] <- "time_since_tube_change"
data<- cbind(data, time_since_tube_change)

## An Explanation of variables: 
# Geom. Mean—The geometric mean. Can be a more applicable metric for a log-normal distribution. It is always less than or equal to the arithmetic mean.
# Robust Standard Deviation—68.26% of the events around the Median are used for this calculation, and an upper and lower range set.  The robust standard deviation is equal to (upper range + lower range) /2.  If the upper range is off scale, the robust standard deviation is equal to the lower range, and vice versa when the lower range is off scale and the robust standard deviation is the upper range.  The robust standard deviation is not as skewed by outlying values as the Standard Deviation.
# Robust CV—Equals 100 * 1/2( Intensity[at 84.13 percentile] – Intensity [at 15.87 percentile] ) / Median. The robust CV is not as skewed by outlying values as the CV.

# Extract the more useful data
d_ss <- data %>%
  select(`flask`,attempt, hour_index, hr_since_light, FAhi, AorM, repli,light_regime,julian_time,sample_datetime, sample_time,lightORdark,time_since_tube_change,`Picochlorum Events/μL(V)`, `Picochlorum Median FSC-A`, `Picochlorum Median SSC-A`, `Picochlorum Median PC5.5-A`)

# Gets the mean of replicates 
d_ss_mean <- d_ss %>% 
  group_by(flask, attempt,hour_index, hr_since_light, FAhi, AorM,light_regime, julian_time,sample_datetime, sample_time, lightORdark, time_since_tube_change) %>% 
  summarise_at(.vars = names(.)[14:17],
               .funs = c(mean="mean"))

```

This chunk processes the temp data in the lab 

```{r, echo = FALSE, message = FALSE}
# Add in temp and humidity data from Govee recording device
# Read the Temperature Data
myfiles = list.files(path="../data/metadata/GEEK temp sensor1615178083103_export", pattern="*.csv", full.names=TRUE)
data_all <- lapply(myfiles, read_csv)
tempdata <- do.call(rbind, data_all)

colnames(tempdata) <- c("datetime", "Temperature", "Humidity")
ggplot(tempdata, aes(x = datetime, y = Temperature)) + 
  geom_line() + 
  geom_smooth()

```


This chunk contains the formatting for the normal graphics. Includes grey box and PROPER log transformation of y axis
```{r}
# TEMPORARY GRAPHIC - This includes code for: 
# Log transformation of y axis 
# Addition of grey box for dark portion of light regime 

# to add: 
# Make axis ticks better and overall aesthetic... 

FLASK<- filter(d_ss,flask == "E")
events <- ggplot(FLASK, aes(x = sample_datetime, y = `Picochlorum Events/μL(V)`))+ 
    scale_y_continuous(trans = "log10", sec.axis = sec_axis(~./4, name = "Temperature"))
plot_limits<-get_plot_limits(events)
events <- events + annotate(geom = "rect", 
                            xmin=as_datetime(filter(flaskdata, flask =="E")$dark_on_datetime_1),
                            xmax=as_datetime(filter(flaskdata, flask =="E")$light_on_datetime_2), 
                            ymin=10^plot_limits[[3]], 
                            ymax=10^plot_limits[[4]], alpha= 0.5, fill = "black") +
  geom_point(aes(color = AorM)) +
  xlab("Sample Date Time") +
  ylab("Log(Events/μL)") + 
  ggtitle("All Flasks Picochlorum Events/μL")
  labs(col="Light \nCondition") +
  theme_bw()+ 
  theme(axis.text=element_text(size=12),
        axis.title=element_text(size=12,face="bold"),
        legend.title =element_text(size=12,face="bold"),
        legend.text = element_text(size=12),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
  #png(file.path("../report/img","Events_Facet_Wrap.png"), width = 800, height = 600)
  print(events)
  #dev.off()  

```

This chunk plots the preservation of samples by plotting Auto against manual samples for %change in parameter against time in the storage unit. In fact, it seems like the manual sample is more influenced by sampling error than the degradation of the samples in the storage unit are affected by time. 
```{r}
# Comparing A and M samples

# Keep only rows of FAhi where both A and M exist
d_ss_mean_AM <- subset(d_ss_mean, FAhi %in% d_ss_mean[duplicated(d_ss_mean$FAhi),"FAhi"]$FAhi)

# Compare differences in 
d_ss_mean_AM_A <- filter(d_ss_mean_AM,AorM == "A")
d_ss_mean_AM_M <- filter(d_ss_mean_AM,AorM == "M")
d_ss_mean_AM_A_ratio <-data.frame(c(d_ss_mean_AM_A[12],d_ss_mean_AM_A[-c(1:12)]/d_ss_mean_AM_M[-c(1:12)]))%>%
  rename("Events/μL" = Picochlorum.Events.μL.V._mean,
         "FSC" = Picochlorum.Median.FSC.A_mean,
         "SSC" = Picochlorum.Median.SSC.A_mean,
         "PC5.5" = Picochlorum.Median.PC5.5.A_mean)
d_ss_mean_AM_A_ratio <- d_ss_mean_AM_A_ratio %>% gather(parameter, ratio, -time_since_tube_change)

preservation_plot <- ggplot(d_ss_mean_AM_A_ratio, aes(x = time_since_tube_change, y = ratio))+
  geom_point() +
  geom_hline(yintercept=1, linetype="dashed", color = "red")+
  xlab("Time Since Tube Change") +
  ylab("Ratio of Stored against Immediate analysis") + 
  theme_bw()
preservation_plot <-  preservation_plot + facet_wrap(~parameter)

png(file.path("../report/img","preservation_plot.png"), width = 800, height = 600)
  print(preservation_plot)
dev.off()  

```

This chunk finds a nonparametric regression estimate and its derivative for cell conc against time. This allows us to find point in time of max instantaneous growth rate.
```{r}
crit_pts_all_para <- data.frame()

# Derivatives of events/ul graph to determine instantaneous growth rates!! 
# Trying out npregfast package to get nonparametric derivative estimations 

# For Events data 
crit_pts_all <- data.frame()
all_der_plots <- list()
for (letter in unique(d_ss_mean$flask)) {
  # remove A because it is the time is not continuous for 24h 
  if (letter == "A"){
  } else {
  # Mask out the first and last few points from the dataset 
  FLASK <- d_ss_mean %>% 
  filter(flask == letter, hr_since_light >=2 & hr_since_light <= 23) %>%
  rename(events = `Picochlorum Events/μL(V)_mean`)
  # Use npregfast::frfast to get the fit data 
  fit <- frfast(events~ hr_since_light, data = FLASK, p=2,h0=0.16, rank1 =9, ranku= 17, kbin = 300)
  # Extract Critical points data 
  crit_pts <-data.frame(matrix(unlist(critical(fit)), nrow=length(critical(fit)), byrow=TRUE)) %>%
  mutate(der = c("Estimation","First_der","Second_der")) %>%
  mutate(flask = rep(letter, 3)) %>%
  rename(Critical = X1,
         Lwr = X2,
         Upr = X3) 
  
  # Store ALL crit pt data
  crit_pts_all <- rbind(crit_pts_all, crit_pts)

  # Create plots
  est_plot <- autoplot(fit) + 
    geom_vline(xintercept = crit_pts[2,1], col = "red") +
    scale_x_continuous(breaks = breaks_width(2, 0)) + 
    ggtitle(paste("Flask",letter, sep = " ")) + 
    labs(x = 'Hours Since Start')
  
  plot_limits <-get_plot_limits(est_plot)
  est_plot <- est_plot + annotate(geom = "rect", 
                            xmin=filter(flaskdata, flask ==letter)$dark1_since_light1,
                            xmax=filter(flaskdata, flask ==letter)$light2_since_light1, 
                            ymin=plot_limits[[3]], 
                            ymax=plot_limits[[4]], alpha= 0.3, fill = "black")
  
  der1_plot <- autoplot(fit, der = 1) + 
    geom_vline(xintercept = crit_pts[2,1], col = "red") + 
    scale_y_continuous(breaks = breaks_pretty(6),labels = hr2day) + 
    scale_x_continuous(breaks = breaks_width(2, 0)) + 
    labs(x = 'Hours Since Start', y = bquote(.(colnames(FLASK)[13]) ~ d^-1))
  
  plot_limits <-get_plot_limits(der1_plot)
  der1_plot <- der1_plot + annotate(geom = "rect", 
                            xmin=filter(flaskdata, flask ==letter)$dark1_since_light1,
                            xmax=filter(flaskdata, flask ==letter)$light2_since_light1, 
                            ymin=plot_limits[[3]], 
                            ymax=plot_limits[[4]], alpha= 0.3, fill = "black")
  
  # Change colour of lines for each light_regime 
  if (FLASK$light_regime[1] == "1608"){
    use_col <- gg_color_hue(3)[3]
  }else if (FLASK$light_regime[1] == "1212") {
    use_col <- gg_color_hue(3)[2]
    } else {
      use_col <- gg_color_hue(3)[1]
      }
  
  
  # Store the derivative plot and add flask name 
  # Also add text indicating light regime 
  grob <- grobTree(textGrob(paste("Light Regime: ", FLASK$light_regime[1]), x=0,  y=0.95, hjust=0,
  gp=gpar(col=use_col, fontsize=13)))
  xmin<- 7
  xmax<-17
  
  if(filter(flaskdata, flask ==letter)$dark1_since_light1[1] <= xmin){
    darkmin <- xmin
    } else {darkmin<- filter(flaskdata, flask ==letter)$dark1_since_light1}
  
  if(filter(flaskdata, flask ==letter)$light2_since_light1[1]>=xmax){
    darkmax <- xmax
    } else {darkmax <- filter(flaskdata, flask ==letter)$light2_since_light1}

  all_der_plots[[letter]] <- der1_plot + 
    ggtitle(paste("Flask",letter, sep = " ")) +
    annotation_custom(grob) + 
    scale_x_continuous(breaks = breaks_width(2, 0), limits = c(xmin,xmax)) + 
    annotate(geom = "rect", 
             xmin=darkmin,
             xmax=darkmax, 
             ymin=plot_limits[[3]], 
             ymax=plot_limits[[4]], alpha= 0.3, fill = "black") +
    geom_vline(xintercept = crit_pts[2,1], col = use_col, lwd = 2)
  
  # create list for grobs in gridExtra
  p <- list(est_plot,der1_plot)
  
  # Store plots in img folder
  dev.new()
    png(file.path("../report/img",paste("model_EVENTS_der", letter, ".png", sep="_")), width = 800, height = 800)
    gridExtra::grid.arrange(grobs = p, ncol = 1, nrow = length(p))
  dev.off()    
  }
}

# Create a plot of all derivatives stacked on top of each other (except A, H, and I)
# remove unnecessary plots from list 
all_der_plots <- within(all_der_plots, rm(H, I)) 
# Reorder so that light regimes are in order 
all_der_plots <- all_der_plots[c("B", "E", "F", "G", "L", "J", "K")]

dev.new()
png(file.path("../report/img",paste("model_EVENTS_der", "ALL", ".png", sep="_")), width = 800, height = 1600)
gridExtra::grid.arrange(grobs = all_der_plots , ncol = 1, nrow = length(all_der_plots))
dev.off()  

# Make a scatter plot for the points 
events_change <- crit_pts_all%>%
  filter(der == "First_der") %>%
  select(Critical, flask) %>%
  mutate(light_regime = c("1608", "1608", "1608", "1212", "1212", "0816", "0816", "0816", "1212")) %>%
  filter(flask %in% c("B", "E", "F", "G", "J", "K", "L"))

dev.new()
  png(file.path("../report/img",paste("Max_Events", "Change", ".png", sep="_")), width = 1200, height = 300)
ggplot(events_change, aes(light_regime, Critical))+
    geom_point(aes(color = light_regime, size = 2)) + 
    coord_flip() +
    geom_text(aes(label= flask),hjust=1.5, vjust=-1) + 
    scale_y_continuous(limits = c(range(events_change$Critical)[1]-1,range(events_change$Critical)[2]+1 )) +
    theme_bw() +
    ggtitle("Events change") + 
    theme(axis.text=element_text(size=16),
        axis.title=element_text(size=16,face="bold"),
        legend.title =element_text(size=16,face="bold"),
        legend.text = element_text(size=16))
dev.off()

crit_pts_all <- mutate(crit_pts_all, parameter = rep("events", nrow(crit_pts_all)))
crit_pts_all_para <- rbind(crit_pts_all_para, crit_pts_all)

graphics.off()
```

For FSC 
```{r}

#### For FSC

crit_pts_all <- data.frame()
all_est_plots <- list()
for (letter in unique(d_ss_mean$flask)) {
  # Mask out the first and last few points from the dataset 
  FLASK <- d_ss_mean %>% 
  filter(flask == letter) %>%
  rename(FSC = `Picochlorum Median FSC-A_mean`)
  # Use npregfast::frfast to get the fit data 
  fit <- frfast(FSC ~ hr_since_light, data = FLASK, p=2,h0=0.16, rank1 =9, ranku= 17, kbin = 300)
  # Extract Critical points data 
  crit_pts <-data.frame(matrix(unlist(critical(fit)), nrow=length(critical(fit)), byrow=TRUE)) %>%
  mutate(der = c("Estimation","First_der","Second_der")) %>%
  mutate(flask = rep(letter, 3)) %>%
  rename(Critical = X1,
         Lwr = X2,
         Upr = X3) 
  
  # Store ALL crit pt data
  crit_pts_all <- rbind(crit_pts_all, crit_pts)

  # Create plots
  est_plot <- autoplot(fit) 
  
  # Get plot limits for grey box 
  plot_limits <-get_plot_limits(est_plot)
  
  # Change colour of lines for each light_regime 
  if (FLASK$light_regime[1] == "1608"){
    use_col <- gg_color_hue(3)[3]
  }else if (FLASK$light_regime[1] == "1212") {
    use_col <- gg_color_hue(3)[2]
    } else {
      use_col <- gg_color_hue(3)[1]
      }
  
  # Create Text for Light Regime 
  grob <- grobTree(textGrob(paste("Light Regime: ", FLASK$light_regime[1]), x=0,  y=0.95, hjust=0,
  gp=gpar(col=use_col, fontsize=13)))
  xmin<- 0
  xmax<-24
  
  if(filter(flaskdata, flask ==letter)$dark1_since_light1[1] <= xmin){
    darkmin <- xmin
    } else {darkmin<- filter(flaskdata, flask ==letter)$dark1_since_light1}
  
  if(filter(flaskdata, flask ==letter)$light2_since_light1[1]>=xmax){
    darkmax <- xmax
  } else {darkmax <- filter(flaskdata, flask ==letter)$light2_since_light1}
  
# Add Plot attributes 
 est_plot <- est_plot + 
   annotate(geom = "rect", 
            xmin=darkmin,
            xmax=darkmax, 
            ymin=plot_limits[[3]], 
            ymax=plot_limits[[4]], alpha= 0.3, fill = "black") + 
   geom_vline(xintercept = crit_pts[1,1],  col = use_col, lwd = 2) +
   scale_x_continuous(breaks = breaks_width(2, 0), limits = c(xmin,xmax)) + 
   ggtitle(paste("Flask",letter, sep = " ")) + 
   labs(x = 'Hours Since Start') +
   annotation_custom(grob)
  
  all_est_plots[[letter]] <- est_plot 
}

# Create a plot of all derivatives stacked on top of each other (except A, H, and I)
# remove unnecessary plots from list
all_est_plots <- within(all_est_plots, rm(A))
# Reorder so that light regimes are in order
all_est_plots <- all_est_plots[c("B", "E", "F", "G","H","L", "I", "J", "K")]

dev.new()
png(file.path("../report/img",paste("model_FSC", "ALL", ".png", sep="_")), width = 800, height = 1600)
gridExtra::grid.arrange(grobs = all_est_plots , ncol = 1, nrow = length(all_est_plots))
dev.off()

# Make a scatter plot for the points
change <- crit_pts_all%>%
  filter(der == "Estimation") %>%
  select(Critical, flask) %>%
  mutate(light_regime = c("1608", "1608", "1608", "1608", "1212", "1212", "0816", "0816", "0816", "1212")) %>%
  filter(flask %in% c("B", "E", "F", "G","H","L", "I", "J", "K"))

dev.new()
  png(file.path("../report/img",paste("Max_FSC", "Change", ".png", sep="_")), width = 1200, height = 300)
ggplot(change, aes(light_regime, Critical))+
    geom_point(aes(color = light_regime, size = 2)) +
    coord_flip() +
    geom_text(aes(label= flask),hjust=1.5, vjust=-1) +
    scale_y_continuous(limits = c(range(change$Critical)[1]-1,range(change$Critical)[2]+1 )) +
    theme_bw() +
    ggtitle("FSC") +
    theme(axis.text=element_text(size=16),
        axis.title=element_text(size=16,face="bold"),
        legend.title =element_text(size=16,face="bold"),
        legend.text = element_text(size=16))
dev.off()

crit_pts_all <- mutate(crit_pts_all, parameter = rep("FSC", nrow(crit_pts_all)))
crit_pts_all_para <- rbind(crit_pts_all_para, crit_pts_all)

graphics.off()
```

For SSC
```{r}

#### For SSC

crit_pts_all <- data.frame()
all_est_plots <- list()
for (letter in unique(d_ss_mean$flask)) {
  # Mask out the first and last few points from the dataset 
  FLASK <- d_ss_mean %>% 
  filter(flask == letter) %>%
  rename(SSC = `Picochlorum Median SSC-A_mean`)
  # Use npregfast::frfast to get the fit data 
  fit <- frfast(SSC ~ hr_since_light, data = FLASK, p=2,h0=0.16, rank1 =9, ranku= 17, kbin = 300)
  # Extract Critical points data 
  crit_pts <-data.frame(matrix(unlist(critical(fit)), nrow=length(critical(fit)), byrow=TRUE)) %>%
  mutate(der = c("Estimation","First_der","Second_der")) %>%
  mutate(flask = rep(letter, 3)) %>%
  rename(Critical = X1,
         Lwr = X2,
         Upr = X3) 
  
  # Store ALL crit pt data
  crit_pts_all <- rbind(crit_pts_all, crit_pts)

  # Create plots
  est_plot <- autoplot(fit) 
  
  # Get plot limits for grey box 
  plot_limits <-get_plot_limits(est_plot)
  
  # Change colour of lines for each light_regime 
  if (FLASK$light_regime[1] == "1608"){
    use_col <- gg_color_hue(3)[3]
  }else if (FLASK$light_regime[1] == "1212") {
    use_col <- gg_color_hue(3)[2]
    } else {
      use_col <- gg_color_hue(3)[1]
      }
  
  # Create Text for Light Regime 
  grob <- grobTree(textGrob(paste("Light Regime: ", FLASK$light_regime[1]), x=0,  y=0.95, hjust=0,
  gp=gpar(col=use_col, fontsize=13)))
  xmin<- 0
  xmax<-24
  
  if(filter(flaskdata, flask ==letter)$dark1_since_light1[1] <= xmin){
    darkmin <- xmin
    } else {darkmin<- filter(flaskdata, flask ==letter)$dark1_since_light1}
  
  if(filter(flaskdata, flask ==letter)$light2_since_light1[1]>=xmax){
    darkmax <- xmax
  } else {darkmax <- filter(flaskdata, flask ==letter)$light2_since_light1}
  
# Add Plot attributes 
 est_plot <- est_plot + 
   annotate(geom = "rect", 
            xmin=darkmin,
            xmax=darkmax, 
            ymin=plot_limits[[3]], 
            ymax=plot_limits[[4]], alpha= 0.3, fill = "black") + 
   geom_vline(xintercept = crit_pts[1,1],  col = use_col, lwd = 2) +
   scale_x_continuous(breaks = breaks_width(2, 0), limits = c(xmin,xmax)) + 
   ggtitle(paste("Flask",letter, sep = " ")) + 
   labs(x = 'Hours Since Start') +
   annotation_custom(grob)
  
  all_est_plots[[letter]] <- est_plot 
}

# Create a plot of all derivatives stacked on top of each other (except A, H, and I)
# remove unnecessary plots from list
all_est_plots <- within(all_est_plots, rm(A))
# Reorder so that light regimes are in order
all_est_plots <- all_est_plots[c("B", "E", "F", "G","H","L", "I", "J", "K")]

dev.new()
png(file.path("../report/img",paste("model_SSC", "ALL", ".png", sep="_")), width = 800, height = 1600)
gridExtra::grid.arrange(grobs = all_est_plots , ncol = 1, nrow = length(all_est_plots))
dev.off()

# Make a scatter plot for the points
change <- crit_pts_all%>%
  filter(der == "Estimation") %>%
  select(Critical, flask) %>%
  mutate(light_regime = c("1608", "1608", "1608", "1608", "1212", "1212", "0816", "0816", "0816", "1212")) %>%
  filter(flask %in% c("B", "E", "F", "G","H","L", "I", "J", "K"))

dev.new()
  png(file.path("../report/img",paste("Max_SSC", "Change", ".png", sep="_")), width = 1200, height = 300)
ggplot(change, aes(light_regime, Critical))+
    geom_point(aes(color = light_regime, size = 2)) +
    coord_flip() +
    geom_text(aes(label= flask),hjust=1.5, vjust=-1) +
    scale_y_continuous(limits = c(range(change$Critical)[1]-1,range(change$Critical)[2]+1 )) +
    theme_bw() +
    ggtitle("SSC") +
    theme(axis.text=element_text(size=16),
        axis.title=element_text(size=16,face="bold"),
        legend.title =element_text(size=16,face="bold"),
        legend.text = element_text(size=16))
dev.off()

crit_pts_all <- mutate(crit_pts_all, parameter = rep("SSC", nrow(crit_pts_all)))
crit_pts_all_para <- rbind(crit_pts_all_para, crit_pts_all)

graphics.off()
```

For PC5.5
```{r}

#### For PC5.5

crit_pts_all <- data.frame()
all_est_plots <- list()
for (letter in unique(d_ss_mean$flask)) {
  # Mask out the first and last few points from the dataset 
  FLASK <- d_ss_mean %>% 
  filter(flask == letter) %>%
  rename(PC5.5 = `Picochlorum Median PC5.5-A_mean`)
  # Use npregfast::frfast to get the fit data 
  fit <- frfast(PC5.5 ~ hr_since_light, data = FLASK, p=2,h0=0.16, rank1 =9, ranku= 17, kbin = 300)
  # Extract Critical points data 
  crit_pts <-data.frame(matrix(unlist(critical(fit)), nrow=length(critical(fit)), byrow=TRUE)) %>%
  mutate(der = c("Estimation","First_der","Second_der")) %>%
  mutate(flask = rep(letter, 3)) %>%
  rename(Critical = X1,
         Lwr = X2,
         Upr = X3) 
  
  # Store ALL crit pt data
  crit_pts_all <- rbind(crit_pts_all, crit_pts)

  # Create plots
  est_plot <- autoplot(fit) 
  
  # Get plot limits for grey box 
  plot_limits <-get_plot_limits(est_plot)
  
  # Change colour of lines for each light_regime 
  if (FLASK$light_regime[1] == "1608"){
    use_col <- gg_color_hue(3)[3]
  }else if (FLASK$light_regime[1] == "1212") {
    use_col <- gg_color_hue(3)[2]
    } else {
      use_col <- gg_color_hue(3)[1]
      }
  
  # Create Text for Light Regime 
  grob <- grobTree(textGrob(paste("Light Regime: ", FLASK$light_regime[1]), x=0,  y=0.95, hjust=0,
  gp=gpar(col=use_col, fontsize=13)))
  xmin<- 0
  xmax<-24
  
  if(filter(flaskdata, flask ==letter)$dark1_since_light1[1] <= xmin){
    darkmin <- xmin
    } else {darkmin<- filter(flaskdata, flask ==letter)$dark1_since_light1}
  
  if(filter(flaskdata, flask ==letter)$light2_since_light1[1]>=xmax){
    darkmax <- xmax
  } else {darkmax <- filter(flaskdata, flask ==letter)$light2_since_light1}
  
# Add Plot attributes 
 est_plot <- est_plot + 
   annotate(geom = "rect", 
            xmin=darkmin,
            xmax=darkmax, 
            ymin=plot_limits[[3]], 
            ymax=plot_limits[[4]], alpha= 0.3, fill = "black") + 
   geom_vline(xintercept = crit_pts[1,1],  col = use_col, lwd = 2) +
   scale_x_continuous(breaks = breaks_width(2, 0), limits = c(xmin,xmax)) + 
   ggtitle(paste("Flask",letter, sep = " ")) + 
   labs(x = 'Hours Since Start') +
   annotation_custom(grob)
  
  all_est_plots[[letter]] <- est_plot 
}

# Create a plot of all derivatives stacked on top of each other (except A, H, and I)
# remove unnecessary plots from list
all_est_plots <- within(all_est_plots, rm(A))
# Reorder so that light regimes are in order
all_est_plots <- all_est_plots[c("B", "E", "F", "G","H","L", "I", "J", "K")]

dev.new()
png(file.path("../report/img",paste("model_PC5.5", "ALL", ".png", sep="_")), width = 800, height = 1600)
gridExtra::grid.arrange(grobs = all_est_plots , ncol = 1, nrow = length(all_est_plots))
dev.off()

# Make a scatter plot for the points
change <- crit_pts_all%>%
  filter(der == "Estimation") %>%
  select(Critical, flask) %>%
  mutate(light_regime = c("1608", "1608", "1608", "1608", "1212", "1212", "0816", "0816", "0816", "1212")) %>%
  filter(flask %in% c("B", "E", "F", "G","H","L", "I", "J", "K"))

dev.new()
  png(file.path("../report/img",paste("Max_PC5.5", "Change", ".png", sep="_")), width = 1200, height = 300)
ggplot(change, aes(light_regime, Critical))+
    geom_point(aes(color = light_regime, size = 2)) +
    coord_flip() +
    geom_text(aes(label= flask),hjust=1.5, vjust=-1) +
    scale_y_continuous(limits = c(range(change$Critical)[1]-1,range(change$Critical)[2]+1 )) +
    theme_bw() +
    ggtitle("PC5.5") +
    theme(axis.text=element_text(size=16),
        axis.title=element_text(size=16,face="bold"),
        legend.title =element_text(size=16,face="bold"),
        legend.text = element_text(size=16))
dev.off()

crit_pts_all <- mutate(crit_pts_all, parameter = rep("PC5.5", nrow(crit_pts_all)))
crit_pts_all_para <- rbind(crit_pts_all_para, crit_pts_all)

graphics.off()
```

Chi Square test for crit values
```{r}
crit_pts_all_para

# chi sq for events
event_crit <- filter(crit_pts_all_para, der == "First_der", parameter == "events") %>% 
  filter(!grepl("H", flask))

mean(event_crit$Critical)
diff_all <- data.frame()
for (time in 1:nrow(event_crit)) {
diff <- ((event_crit[time,1] - mean(event_crit$Critical))^2)/mean(event_crit$Critical)
diff_all<- rbind(diff_all,diff)
}
sum(diff_all)

```




-----------------Everything below here is irrelevant-------------------
This chunk imports a xsls file and converts it to latex table
```{r}
library(xtable)
library(readxl)

get_table <- function (csv_path){
  table <- read_excel(csv_path)
  print(xtable(table), 
        comment = FALSE)
}

get_table("/Users/davidmah/Desktop/Flask Data.xlsx")

```





This chunk basically plots all the normal graphics for parameter against time
```{r}
## Plot for Events

# Facet wrap plot of all Flasks together
events <- ggplot(d_ss, aes(x = julian_time, y = log(`Picochlorum Events/μL(V)`)))+
  geom_smooth() +
  geom_point(aes(color = lightORdark)) +
  xlab("Time Since Start") +
  ylab("Log(Events/μL)") + 
  ggtitle("All Flasks Picochlorum Events/μL")
  labs(col="Light \nCondition") +
  theme_bw()+ 
  theme(axis.text=element_text(size=12),
        axis.title=element_text(size=12,face="bold"),
        legend.title =element_text(size=12,face="bold"),
        legend.text = element_text(size=12)) 
events <- events + facet_wrap(~flask)
  png(file.path("../report/img","Events_Facet_Wrap.png"), width = 800, height = 600)
  print(events)
  dev.off()  


# Plot for Events/μL
for (letter in unique(d_ss$flask)) {
  FLASK<- filter(d_ss,flask == letter)
events <- ggplot(FLASK, aes(x = FLASK$julian_time, y = FLASK$`Picochlorum Events/μL(V)`))+
    geom_point(aes(color = lightORdark)) +
    xlab("Time since start") +
    ylab("Median Events/μL") + 
    labs(col="Light \nCondition") +
    theme_bw() +
    ggtitle(paste("Flask", letter)) + 
    theme(plot.title = element_text(size = 28, face = "bold"),
          axis.text=element_text(size=20),
          axis.title=element_text(size=20,face="bold"),
          legend.title =element_text(size=20,face="bold"),
          legend.text = element_text(size=20)) 
    # Create and store plots in img folder
  dev.new()
    png(file.path("../report/img",paste("Events", letter, ".png", sep="_")), width = 800, height = 600)
  print(events)
  dev.off()  
}
  
# Plot for log(Events)/μL
for (letter in unique(d_ss$flask)) {
  FLASK<- filter(d_ss,flask == letter)
events <- ggplot(FLASK, aes(x = FLASK$julian_time, y = log(FLASK$`Picochlorum Events/μL(V)`)))+
    geom_point(aes(color = lightORdark)) +
    xlab("Time since start") +
    ylab("Log(Median Events)/μL") + 
    labs(col="Light \nCondition") +
    theme_bw() +
    ggtitle(paste("Flask", letter)) + 
    theme(plot.title = element_text(size = 28, face = "bold"),
          axis.text=element_text(size=20),
          axis.title=element_text(size=20,face="bold"),
          legend.title =element_text(size=20,face="bold"),
          legend.text = element_text(size=20)) 
    # Create and store plots in img folder
  dev.new()
    png(file.path("../report/img",paste("Events_log", letter, ".png", sep="_")), width = 800, height = 600)
  print(events)
  dev.off()  
}

# Plot for FSC
for (letter in unique(d_ss$flask)) {
  FLASK<- filter(d_ss,flask == letter)
  FSC <- ggplot(FLASK, aes(x = FLASK$julian_time, y = FLASK$`Picochlorum Median FSC-A`))+
    geom_point(aes(color = lightORdark)) +
    xlab("Time since start") +
    ylab("Median FSC") + 
    labs(col="Light \nCondition") +
    theme_bw() +
    ggtitle(paste("Flask", letter)) + 
    theme(plot.title = element_text(size = 28, face = "bold"),
          axis.text=element_text(size=20),
          axis.title=element_text(size=20,face="bold"),
          legend.title =element_text(size=20,face="bold"),
          legend.text = element_text(size=20)) 
    # Create and store plots in img folder
  dev.new()
    png(file.path("../report/img",paste("FSC", letter, ".png", sep="_")), width = 800, height = 600)
  print(FSC)
  dev.off()
}

# Plot for SSC
for (letter in unique(d_ss$flask)) {
  FLASK<- filter(d_ss,flask == letter)
SSC <- ggplot(FLASK, aes(x = FLASK$julian_time, y = FLASK$`Picochlorum Median SSC-A`))+
    geom_point(aes(color = lightORdark)) +
    xlab("Time since start") +
    ylab("Median SSC") + 
    labs(col="Light \nCondition") +
    theme_bw() +
    ggtitle(paste("Flask", letter)) + 
    theme(plot.title = element_text(size = 28, face = "bold"),
          axis.text=element_text(size=20),
          axis.title=element_text(size=20,face="bold"),
          legend.title =element_text(size=20,face="bold"),
          legend.text = element_text(size=20)) 
    # Create and store plots in img folder
  dev.new()
    png(file.path("../report/img",paste("SSC", letter, ".png", sep="_")), width = 800, height = 600)
  print(SSC)
  dev.off()  
}

# Plot for CHL-A 
for (letter in unique(d_ss$flask)) {
  FLASK<- filter(d_ss,flask == letter)
PC5.5 <- ggplot(FLASK, aes(x = FLASK$julian_time, y = FLASK$`Picochlorum Median PC5.5-A`))+
    geom_point(aes(color = lightORdark)) +
    xlab("Time since start") +
    ylab("Median PC5.5") + 
    labs(col="Light \nCondition") +
    theme_bw() +
    ggtitle(paste("Flask", letter)) + 
    theme(plot.title = element_text(size = 28, face = "bold"),
          axis.text=element_text(size=20),
          axis.title=element_text(size=20,face="bold"),
          legend.title =element_text(size=20,face="bold"),
          legend.text = element_text(size=20)) 
    # Create and store plots in img folder
  dev.new()
    png(file.path("../report/img",paste("PC5.5", letter, ".png", sep="_")), width = 800, height = 600)
  print(PC5.5)
  dev.off()    
}
  
# This is to clear the device list (dev.list()) 
graphics.off()



## Find out how to normalise this! Use the other columns in your analysis
# Plot of multiple light regimes together 
REGIME<-filter(d_ss,light_regime == "1608")
regime_plot <- ggplot(REGIME, aes(x = REGIME$julian_time, y = REGIME$`Picochlorum Events/μL(V)`))+
  geom_point(aes(color = lightORdark, shape = flask)) +
  xlab("Time Since Start") +
  ylab("FSC") + 
  labs(col="Light \nCondition", shape = "Flask") +
  theme_bw()+ 
  theme(axis.text=element_text(size=28),
        axis.title=element_text(size=28,face="bold"),
        legend.title =element_text(size=28,face="bold"),
        legend.text = element_text(size=28))
regime_plot



```

Example of how to use npregfast
```{r}

#### EXAMPLE DATASET #####
data(barnacle)
# Nonparametric regression without interactions

fit <- frfast(DW ~ RC, data = barnacle, nboot = 100, smooth = "kernel")
# using splines
fit <- frfast(DW ~ s(RC), data = barnacle, nboot = 100, smooth = "splines", cluster = TRUE, ncores = 2)
fit
#summary(fit)
fit <- frfast(DW ~ RC, data = barnacle, nboot = 50)
autoplot(fit)
autoplot(fit, points = FALSE) + ggtitle("Title")
autoplot(fit, der = 1) + xlim(4, 20)
autoplot(fit, der = 1, col = "red", CIcol = "blue")
# Nonparametric regression with interactions
fit2 <- frfast(DW ~ RC : F, data = barnacle, nboot = 50)
autoplot(fit2, fac = "barca")
autoplot(fit2, der = 1, fac = "lens")
# Visualization of the differences between two factor's levels
autoplot(fit2, fac = "barca", diffwith = "lens")
autoplot(fit2, der = 1, fac = "barca", diffwith = "lens")
#Plotting in the same graphics device
## Not run:
if (requireNamespace("gridExtra", quietly = TRUE)) {
# For plotting two derivatives in the same graphic windows
ders <- lapply(0:1, function(x) autoplot(fit, der = x))
gridExtra::grid.arrange(grobs = ders, ncol = 2, nrow = 1)
# For plotting two levels in the same graphic windows
facs <- lapply(c("barca", "lens"), function(x) autoplot(fit2, der = 0, fac = x))
gridExtra::grid.arrange(grobs = facs, ncol = 2, nrow = 1)
}
## End(Not run)


# Example of prediction
# Nonparametric regression without interactions
fit <- frfast(DW ~ RC, data = barnacle, nboot = 100)
nd <- data.frame(RC = c(10, 14, 18))
predict(fit, newdata = nd)


# Example of finding critical points in the 1st and 2nd derivative curves 
fit <- frfast(DW ~ RC, data = barnacle) # without interactions
critical(fit)
critical(fit, der = 0)
critical(fit, der = 1)
critical(fit, der = 2)


```

Using psp line and trying to model. Did not work out. 
```{r}

## UPDATE: THIS PORTION IS NO LONGER APPLICABLE BECAUSE npregfast > pspline
# This is because 1. npregfast can hv >1 value at each x axis point in generating a smooth curve, 2. npregfast uses ggplot graphics, 3. npregfast has a smoother curve and the derivative estimate looks visually better than pspline. 4. npregfast has autoplot functions :') 


# Try to get a model for instantaneous growth rates!! 
# Trying out pspline package to get nonparametric derivative estimations 

# Since pspline requires dataset to not have more than 1 value for each point on the x axis, have to find the d_ss_mean, but with all the A and M values meaned out as well. 
library(pspline)
d_ss_mean_noAM <- d_ss_mean %>% 
  group_by(flask, attempt,hour_index,hr_since_light, FAhi,light_regime, julian_time,sample_datetime, sample_time, lightORdark) %>% 
  summarise_at(.vars = names(.)[13:16],
               .funs = c(mean="mean"))

# Test flask use E 
FLASK <- filter(d_ss_mean_noAM, flask == "E")

# create estimate of curve using smooth.Pspline() function 
pspl <- smooth.Pspline(FLASK$julian_time, FLASK$`Picochlorum Events/μL(V)_mean_mean`,norder =3 )
d0 <- predict(pspl, FLASK$julian_time, nderiv=0)
plot(pspl)
lines(FLASK$julian_time, d0, lwd=3, lty=2, col="red")


d1 <- predict(pspl, FLASK$julian_time, nderiv=1)
plot(FLASK$julian_time, d1)
lines(FLASK$julian_time, d1, lwd=3, lty=2, col="red")
gr_data <- data.frame("x" = FLASK$julian_time, "y" =FLASK$`Picochlorum Events/μL(V)_mean_mean`, "d0" = d0, "d1" = d1)

p <- ggplot(data =gr_data) + 
  geom_point(aes(x = x, y = d1)) + 
  geom_smooth(aes(x = x, y = y))

  geom_point(aes(x=x, y= d1))

print(p)


## UPDATE: This portion is no longer applicable because linear models are trash D: 
# Linear Model of Ln Events/ul to get growth rates etc 

# Create function to generate regression plot 
ggplotRegression <- function (fit) {
require(ggplot2)
ggplot(fit$model, aes(x = fit$model[,2], y = fit$model[,1])) + 
  geom_point() +
  stat_smooth(method = "lm", col = "red") +
  xlab(names(model$model[2]))+ 
  ylab(names(model$model[1])) +
  labs(title = paste("Adj R2 = ",signif(summary(fit)$adj.r.squared, 5),
                     "Intercept =",signif(fit$coef[[1]],5 ),
                     " Slope =",signif(fit$coef[[2]], 5),
                     " P =",signif(summary(fit)$coef[2,4], 5))) +
  theme_bw()
}

# Create function to capture and calculate growth rate data
growth_rate <- function (model){
  # Use fitted.values so that you are taking the slope of the linear model and not calculating growth rates based on 1st and last points alone! 
  (last(model$fitted.values)-first(model$fitted.values))/as.numeric(last(model$model[2][,1])-first(model$model[2][,1]))
}

# Plot and store growth rate data
growth_data <- data.frame()
plot_list = list()

for (letter in 1:as.numeric(tally(plyr::count(unique(d_ss_mean$flask))))) {
  FLASK <- filter(d_ss_mean, flask == unique(d_ss_mean$flask)[letter])
  # Plot model for each flask
  model = lm(log(FLASK$`Picochlorum Events/μL(V)_mean`)~ sample_datetime, data = FLASK)
  # Create File path and name for each plot generated
  file_name <- file.path("../report/img",paste("linear_model_flask_", unique(d_ss_mean$flask)[letter], ".png", sep=""))
  # Store all models in a list
  plot_list[[letter]] = model
  # Create plot and add title 
  p <- ggplotRegression(model) + ggtitle(paste("Flask", unique(d_ss_mean$flask)[letter]))
  # Print and store all ggplotRegression plots 
  dev.new()
  png(file.path("../report/img",paste("linear_model_flask_", unique(d_ss_mean$flask)[letter], ".png", sep="")), width = 800, height = 600)
  print(p)
  dev.off()
  # Store all growth rate data in a df 
  growth <- c("r" = growth_rate(model), "k" = growth_rate(model)/log(2), "T2" = log(2)/growth_rate(model))
  growth_data <- rbind(growth_data, growth)
}
colnames(growth_data) <- c("r", "k", "T2")
row.names(growth_data) <- unique(d_ss_mean$flask)

# This is to clear the device list (dev.list()) 
graphics.off()


## Plot instantaneous growth rate against time and then find area under the curve to get average growth rate over period or average mortality rate over period 

# Using stat_smooth to get modeled curve 


FLASK<- filter(d_ss,flask == "E")

events <- ggplot(FLASK, aes(x = FLASK$sample_datetime, y = FLASK$`Picochlorum Events/μL(V)`))+
  geom_point(aes(color = lightORdark)) +
  stat_smooth() + 
  xlab("Time since start") +
  ylab("Median Events/μL") + 
  labs(col="Light \nCondition") +
  theme_bw() +
  ggtitle(paste("Flask", "E")) + 
  theme(plot.title = element_text(size = 28, face = "bold"),
        axis.text=element_text(size=20),
        axis.title=element_text(size=20,face="bold"),
        legend.title =element_text(size=20,face="bold"),
        legend.text = element_text(size=20)) 

print(events)
sup <- ggplot_build(events)
sup$data[[2]]
  

  
# Gets a little confusing so lets try with ggplot using the splines package
# Also super confusing 

# Another package called npregfast seems possible but is too complicated for me :(


# Try to use lm to fit a model from sin and cos curves 
  # The datetime format is a problem
evnts <- FLASK$`Picochlorum Events/μL(V)`
timee <- FLASK$sample_datetime

model_test <- lm(evnts~sin(as.numeric(timee)))
summary(model_test)

model <- loess(evnts~as.numeric(timee))


tcos<-cos(2*pi*(as.numeric(timee))/1234)
tsin<-sin(2*pi*(as.numeric(timee))/1234)
model <-lm(evnts~tcos + tsin)
summary(model)

model1 <- lm(y~ x + I(sin(2*pi*x/360)))
summary(model1)

model2 <- lm(y~ x + I(sin(2*pi*x/360))+I(cos...))
summary(model2)
# Derivative of this curve is formula for instantaneous growth rate for time (t)

# Integral of the new growth rate curve below line and above axis is growing and below axis and above line is dying

```







